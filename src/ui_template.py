#!/usr/bin/python

# ui_template.py
#
# Mike Bonnington <mjbonnington@gmail.com>
# (c) 2018-2021
#
# A custom class to act as a template for all windows and dialogs.
# This module provides windowing / UI helper functions for better integration
# of PySide / PyQt UIs in supported DCC applications.
# Current support:
# Good: Maya, Nuke
# Partial: Houdini, Clarisse, 3ds Max
# Experimental: Blender
# Future: ?


import os
import platform
import re
import sys
import textwrap

from Qt import QtCompat, QtCore, QtGui, QtSvg, QtWidgets, __binding__, __binding_version__

import ui_chrome_rc  # Import resource file as generated by pyside-rcc
# import rsc_rc  # Import resource file as generated by pyside-rcc - LEGACY

# Import custom modules
import about
# import os_wrapper
import popup
# import verbose


VENDOR = os.getenv('IC_VENDOR', 'mjbonnington')
COPYRIGHT = os.getenv('IC_COPYRIGHT', '(c) 2013-2021')

# ----------------------------------------------------------------------------
# Environment detection
# ----------------------------------------------------------------------------

ENVIRONMENT = os.getenv('IC_ENV', 'standalone')

try:
	import hou
	ENVIRONMENT = 'houdini'
except ImportError:
	pass

try:
	import maya.cmds as mc
	ENVIRONMENT = 'maya'
except ImportError:
	pass

try:
	from pymxs import runtime
	import qtmax
	ENVIRONMENT = 'max'
except ImportError:
	pass

try:
	import nuke
	import nukescripts
	ENVIRONMENT = 'nuke'
except ImportError:
	pass

# ----------------------------------------------------------------------------
# Main window class
# ----------------------------------------------------------------------------

class TemplateUI(object):
	"""Template UI class.

	Subclasses derived from this class need to also inherit QMainWindow or
	QDialog. This class has no __init__ constructor as a fudge to get around
	the idiosyncracies of multiple inheritance whilst retaining	compatibility
	with both Python 2 and 3.
	"""
	#def setupUI(self, **cfg):
	def setupUI(
		self, 
		window_object, 
		window_title="", 
		ui_file="", 
		stylesheet="", 
		prefs_file=None, 
		store_window_geometry=True):
		"""Setup the UI."""

		# verbose.debug("%s %s\n  Parent: %s" % (window_object, self, self.parent))

		# Instantiate preferences data class
		if prefs_file is None:
			self.prefs = None
		else:
			self.prefs = self.createPrefs(prefs_file)

		# Load UI
		try:
			self.ui = QtCompat.loadUi(ui_file, self)
		except:
			# verbose.error("Failed to open UI file: %s" % ui_file)
			print("Failed to open UI file: %s" % ui_file)

		# Store some system UI colours & define colour palette
		self.col = {}
		self.col['text'] = QtGui.QColor(204, 204, 204)
		self.col['disabled'] = QtGui.QColor(102, 102, 102)
		self.col['highlighted-text'] = QtGui.QColor(255, 255, 255)
		tmpWidget = QtWidgets.QWidget()
		self.col['sys-window'] = tmpWidget.palette().color(QtGui.QPalette.Window)
		self.col['sys-highlight'] = tmpWidget.palette().color(QtGui.QPalette.Highlight)
		# self.col['window'] = self.col['sys-window']
		self.col['highlight'] = self.col['sys-highlight']
		self.col['window'] = QtGui.QColor('#444444')
		# self.col['highlight'] = QtGui.QColor('#78909c')
		self.computeUIPalette()

		# Load and set stylesheet
		self.stylesheet = self.checkFilePath(stylesheet)
		self.loadStyleSheet()

		# Set window title
		self.setObjectName(window_object)
		if window_title:
			self.setWindowTitle(window_title)
		else:
			window_title = self.windowTitle()

		# Perform custom widget setup
		self.setupWidgets(self.ui)

		# Restore window geometry and state
		self.store_window_geometry = store_window_geometry
		ui_name = self.objectName()
		if ENVIRONMENT != 'standalone':
			ui_name += "_" + ENVIRONMENT.lower()
		self.settings = QtCore.QSettings(VENDOR, ui_name)
		if self.store_window_geometry:
			try:
				self.restoreGeometry(self.settings.value("geometry", ""))
				# verbose.detail("Restoring window geometry for '%s'." % self.objectName())
			except (KeyError, TypeError):
				# verbose.warning("Could not restore window geometry for '%s'." % self.objectName())
				print("Could not restore window geometry for '%s'." % self.objectName())

			# # Use QSettings to store window geometry and state.
			# # (Restore state may cause issues with PyQt5)
			# if ENVIRONMENT == 'standalone':
			# 	verbose.detail("Restoring window geometry for '%s'." %self.objectName())
			# 	try:
			# 		self.settings = QtCore.QSettings(
			# 			VENDOR, window_title)
			# 		self.restoreGeometry(self.settings.value("geometry", ""))
			# 		# self.restoreState(self.settings.value("windowState", ""))
			# 	except:
			# 		pass

			# # Makes Maya perform magic which makes the window stay on top in
			# # OS X and Linux. As an added bonus, it'll make Maya remember the
			# # window position.
			# elif ENVIRONMENT == 'MAYA':
			# 	self.setProperty("saveWindowPref", True)

			# elif ENVIRONMENT == 'NUKE':
			# 	pass

		else:
			try:
				# Move to centre of parent window
				self.move(self.parent.frameGeometry().center() - self.frameGeometry().center())
			except AttributeError:
				pass
				# # Move to centre of active screen
				# desktop = QtWidgets.QApplication.desktop()
				# screen = desktop.screenNumber(desktop.cursor().pos())
				# self.move(desktop.screenGeometry(screen).center() - self.frameGeometry().center())

		# Set up keyboard shortcuts
		self.shortcutUnloadStyleSheet = QtWidgets.QShortcut(self)
		self.shortcutUnloadStyleSheet.setKey('Ctrl+Shift+R')
		self.shortcutUnloadStyleSheet.activated.connect(self.unloadStyleSheet)

		self.shortcutReloadStyleSheet = QtWidgets.QShortcut(self)
		self.shortcutReloadStyleSheet.setKey('Ctrl+R')
		self.shortcutReloadStyleSheet.activated.connect(self.loadStyleSheet)


	def getInfo(self, formatted=False):
		"""Return some version info about Python, Qt, binding, etc."""

		info = {}
		info['Python'] = "%d.%d.%d" %(sys.version_info[0], sys.version_info[1], sys.version_info[2])
		info[__binding__] = __binding_version__
		info['Qt'] = QtCore.qVersion()
		info['OS'] = platform.system()
		info['Environment'] = ENVIRONMENT

		if formatted:
			info_ls = []
			for key, value in info.items():
				info_ls.append("{} {}".format(key, value))
			info_str = " | ".join(info_ls)
			return info_str

		else:
			return info


	def about(self, 
		app_name="", 
		app_version="0.0.0", 
		credits="", 
		description="", 
		background=os.getenv('IC_SPLASHSCREEN')):
		"""Show standardised popup about dialog."""

		if app_name == "":
			app_name = self.windowTitle()

		info_ls1 = []
		info_ls2 = []
		for key, value in self.getInfo().items():
			if key in ['Environment', 'OS']:
				info_ls1.append(value)
			else:
				info_ls2.append("{} {}".format(key, value))
		info_str1 = "/".join(info_ls1)
		info_str2 = " | ".join(info_ls2)

		about_msg = "%s\n%s (%s)\n\n%s\n%s\n%s %s\n\n%s" % (
			app_name, 
			app_version, info_str1, 
			description, 
			credits, 
			COPYRIGHT, VENDOR, 
			info_str2)

		aboutDialog = about.AboutDialog(parent=self)
		aboutDialog.display(
			bg_image=background, 
			message=about_msg)


	def popup(self, message, attachTo=None): #, parent=None):
		"""Show popup message."""

		popupDialog = popup.PopupDialog(parent=self)
		popupDialog.display(message=message, attachTo=attachTo)


	def createPrefs(self, prefs_file):
		"""Create object to hold preferences.

		Note: I have hacked this to allow an object derived from the class
		'JSONData' to be passed in directly, permitting its extended methods
		to be used.
		Otherwise, assume prefs_file is a string value holding a file path to
		the prefs file to be loaded, and create the prefs object here.
		"""
		# if prefs_file.endswith('.json'):
		# 	from shared import json_metadata as metadata
		# if prefs_file.endswith('.xml'):
		# 	from shared import xml_metadata as metadata

		try:  # Python 2.x
			if type(prefs_file) in [str, unicode]:
				import metadata
				return metadata.Metadata(prefs_file)
			else: # Return the object as-is
				return prefs_file

		except NameError:  # Python 3.x
			if type(prefs_file) is str:
				import metadata
				return metadata.Metadata(prefs_file)
			else: # Return the object as-is
				return prefs_file


	def get_resource(self, rsc_path):
		"""Get a resource file from the current package."""

		try:
			from pkg_resources import resource_filename
			return resource_filename(__name__, rsc_path)
		except ImportError:
			return os.path.join(os.path.dirname(__file__), rsc_path)


	def promptDialog(
		self, 
		message, 
		title=os.getenv('IC_NAME', "Message"), 
		infotext=None, 
		# oktext=None, 
		# canceltext=None, 
		conf=False, 
		modal=True, 
		warn=False):
		"""Open a generic message box dialog."""

		message_box = QtWidgets.QMessageBox(parent=self)
		message_box.setWindowTitle(title)

		if infotext and infotext != "":
			text = "{}\n\n{}".format(message, "\n".join(textwrap.wrap(infotext, width=100)))
		else:
			text = message
		message_box.setText(text)

		if conf:
			message_box.setStandardButtons(QtWidgets.QMessageBox.Ok)
			# if oktext:
			# 	ok_btn = message_box.addButton(oktext, QtWidgets.QMessageBox.AcceptRole)
			# else:
			# 	ok_btn = message_box.addButton(QtWidgets.QMessageBox.Ok)

		else:
			message_box.setStandardButtons(QtWidgets.QMessageBox.Ok | QtWidgets.QMessageBox.Cancel)
			# if oktext:
			# 	ok_btn = message_box.addButton(oktext, QtWidgets.QMessageBox.AcceptRole)
			# else:
			# 	ok_btn = message_box.addButton(QtWidgets.QMessageBox.Ok)
			# if canceltext:
			# 	cancel_btn = message_box.addButton(canceltext, QtWidgets.QMessageBox.RejectRole)
			# else:
			# 	cancel_btn = message_box.addButton(QtWidgets.QMessageBox.Cancel)

		if warn:
			# message_box.setIcon(QtWidgets.QMessageBox.Warning)
			message_box.setIconPixmap(self.iconTint('dialog-warning.svg', tint=self.col['text']))
			self.setDynamicProperty(message_box, 'warn', True)

		message_box.setDefaultButton(message_box.Ok);
		# message_box.setDefaultButton(ok_btn);

		if message_box.exec_() == message_box.Cancel:
			return False
		else:
			return True


	def fileDialog(self, startingDir, fileFilter='All files (*.*)'):
		"""Open a dialog from which to select a single file."""

		dialog = QtWidgets.QFileDialog.getOpenFileName(
			self, self.tr('Files'), startingDir, fileFilter)

		try:
			return dialog[0]
		except IndexError:
			return None


	def fileSaveDialog(self, startingDir, fileFilter='All files (*.*)'):
		"""Open a dialog from which to save a file."""

		dialog = QtWidgets.QFileDialog.getSaveFileName(
			self, self.tr('Save'), startingDir, fileFilter)

		try:
			return dialog[0]
		except IndexError:
			return None


	def folderDialog(self, startingDir):
		"""Open a dialog from which to select a folder."""

		dialog = QtWidgets.QFileDialog.getExistingDirectory(
			self, self.tr('Directory'), startingDir, 
			QtWidgets.QFileDialog.DontResolveSymlinks | QtWidgets.QFileDialog.ShowDirsOnly)

		return dialog


	def colorPickerDialog(self, current_color=None):
		"""Open a system dialog for choosing a colour.

		Return the selected colour as a QColor object, or None if the dialog
		is cancelled.
		"""
		color_dialog = QtWidgets.QColorDialog()
		#color_dialog.setOption(QtWidgets.QColorDialog.DontUseNativeDialog)

		# Set current colour
		if current_color is not None:
			color_dialog.setCurrentColor(current_color)

		# Only return a color if valid / dialog accepted
		if color_dialog.exec_() == color_dialog.Accepted:
			color = color_dialog.selectedColor()
			return color


	# ------------------------------------------------------------------------
	# Widget handlers

	def setupWidgets(self, parentObject, 
		forceCategory=None, 
		inherit=None, 
		storeProperties=True, 
		updateOnly=False):
		"""Set up all the child widgets of the specified parent object.

		If 'forceCategory' is specified, this will override the category of
		all child widgets.
		'inherit' specifies an alternative data source for widgets values.
		If 'storeProperties' is True, the values will be stored in the data
		file as well as applied to the widgets.
		If 'updateOnly' is True, only the widgets' values will be updated.
		"""
		if forceCategory is not None:
			category = forceCategory

		if updateOnly:
			storeProperties = False

		for widget in parentObject.findChildren(QtWidgets.QWidget):

			# Enable expansion of custom rollout group box controls...
			if widget.property('expandable'):
				if isinstance(widget, QtWidgets.QGroupBox):
					widget.setCheckable(True)
					# widget.setChecked(expand)
					widget.setFixedHeight(widget.sizeHint().height())
					if not updateOnly:
						widget.toggled.connect(self.toggleExpandGroup)

			# Set up handler for push buttons...
			if widget.property('exec'):
				if isinstance(widget, QtWidgets.QPushButton):
					if not updateOnly:
						widget.clicked.connect(self.execPushButton)

			# Set up handlers for different widget types & apply values
			attr = widget.property('xmlTag')
			if attr:
				self.base_widget = widget.objectName()
				if forceCategory is None:
					category = self.findCategory(widget)
				if category:
					widget.setProperty('xmlCategory', category)

					if inherit:
						value = self.prefs.get_attr(category, attr)
						# if value == "":
						if value is None:
							value = inherit.get_attr(category, attr)

							# widget.setProperty('xmlTag', None)
							widget.setProperty('inheritedValue', True)
							if widget.toolTip():
								widget.setProperty('oldToolTip', widget.toolTip())
							widget.setToolTip("This value is being inherited. Change the value to override the inherited value.")

							# Apply pop-up menu to remove override - can't get to work here
							# self.addContextMenu(widget, "Remove override", self.remove_overrides)
							# widget.setContextMenuPolicy(QtCore.Qt.ActionsContextMenu)

							# actionRemoveOverride = QtWidgets.QAction("Remove override", None)
							# actionRemoveOverride.triggered.connect(self.remove_overrides)
							# widget.addAction(actionRemoveOverride)
					else:
						try:
							value = self.prefs.get_attr(category, attr)
						except AttributeError:
							value = None

					# Sliders...
					if isinstance(widget, QtWidgets.QSlider):
						if value is not None:
							widget.setValue(int(value))
						if storeProperties:
							self.storeValue(category, attr, widget.value())
						if not updateOnly:
							widget.valueChanged.connect(self.storeSliderValue)

					# Spin boxes...
					if isinstance(widget, QtWidgets.QSpinBox):
						if value is not None:
							widget.setValue(int(value))
						if storeProperties:
							self.storeValue(category, attr, widget.value())
						if not updateOnly:
							widget.valueChanged.connect(self.storeSpinBoxValue)

					# Double spin boxes...
					elif isinstance(widget, QtWidgets.QDoubleSpinBox):
						if value is not None:
							widget.setValue(float(value))
						if storeProperties:
							self.storeValue(category, attr, widget.value())
						if not updateOnly:
							widget.valueChanged.connect(self.storeSpinBoxValue)

					# Line edits...
					elif isinstance(widget, QtWidgets.QLineEdit):
						if value is not None:
							widget.setText(value)
						if storeProperties:
							self.storeValue(category, attr, widget.text())
						if not updateOnly:
							# widget.textEdited.connect(self.storeLineEditValue)
							widget.textChanged.connect(self.storeLineEditValue)

					# Plain text edits...
					elif isinstance(widget, QtWidgets.QPlainTextEdit):
						if value is not None:
							widget.setPlainText(value)
						if storeProperties:
							self.storeValue(category, attr, widget.toPlainText())
						if not updateOnly:
							widget.textChanged.connect(self.storeTextEditValue)

					# Check boxes...
					elif isinstance(widget, QtWidgets.QCheckBox):
						if value is not None:
							if value == True:
								widget.setCheckState(QtCore.Qt.Checked)
							elif value == False:
								widget.setCheckState(QtCore.Qt.Unchecked)
						if storeProperties:
							self.storeValue(category, attr, self.getCheckBoxValue(widget))
						if not updateOnly:
							widget.toggled.connect(self.storeCheckBoxValue)

					# Radio buttons...
					elif isinstance(widget, QtWidgets.QRadioButton):
						if value is not None:
							widget.setAutoExclusive(False)
							if value == widget.text():
								widget.setChecked(True)
							else:
								widget.setChecked(False)
							widget.setAutoExclusive(True)
						if storeProperties:
							if widget.isChecked():
								self.storeValue(category, attr, widget.text())
						if not updateOnly:
							widget.toggled.connect(self.storeRadioButtonValue)

					# Combo boxes...
					elif isinstance(widget, QtWidgets.QComboBox):
						# Add items if history is enabled
						if widget.property('storeHistory'):
							widget.setInsertPolicy(widget.InsertAtTop)
							history = self.prefs.get_attr(category, "%s_history" % attr)
							if history:
								widget.addItems(history)
						# Add/set current item
						if value is not None:
							if widget.findText(value) == -1:
								widget.insertItem(0, value)
							widget.setCurrentIndex(widget.findText(value))
						# Store value in external file
						if storeProperties:
							self.storeValue(category, attr, widget.currentText())
						# Connect signals & slots
						if not updateOnly:
							# widget.currentTextChanged.connect(self.storeComboBoxValue)
							if widget.isEditable():
								widget.editTextChanged.connect(self.storeComboBoxValue)
							else:
								widget.currentIndexChanged.connect(self.storeComboBoxValue)

					# List widgets...
					# TODO: Add option to remove duplicate entries
					elif isinstance(widget, QtWidgets.QListWidget):
						if value is not None:
							# print(value)
							widget.clear()
							widget.addItems(value)
						if storeProperties:
							items = []
							for i in range(widget.count()):
								items.append(widget.item(i).text())
							self.storeValue(category, attr, items)
						if not updateOnly:
							widget.itemChanged.connect(self.storeListWidgetValues)

					# Enable colour chooser buttons...
					elif isinstance(widget, QtWidgets.QToolButton):
						if widget.property('colorChooser'):
							if value is not None:
								widget.setStyleSheet("QWidget { background-color: %s }" % value)
							# if storeProperties:
							# 	self.storeValue(category, attr, widget.currentText())
							if not updateOnly:
								widget.clicked.connect(self.storeColor)


	def disconnectAll(self, parentObject):
		"""Recursively disconnect all signals from widgets that are children
		of parentObject.
		"""
		for widget in parentObject.findChildren(QtWidgets.QWidget):
			if widget.property('xmlTag'):
				try:
					widget.disconnect()
					# verbose.debug("Disconnect signals from %s" % widget.objectName())
				except TypeError:
					pass
					# verbose.debug("No signals to disconnect from %s" % widget.objectName())


	def findCategory(self, widget):
		"""Recursively check the parents of the given widget until a custom
		property 'xmlCategory' is found.
		"""
		# print("widget: " + widget.objectName())
		if widget.property('xmlCategory'):
			#verbose.detail("Category '%s' found for '%s'." %(widget.property('xmlCategory'), widget.objectName()))
			return widget.property('xmlCategory')
		else:
			# # Stop iterating if the widget's parent is the top window...
			# if isinstance(widget.parent(), QtWidgets.QMainWindow) \
			# or isinstance(widget.parent(), QtWidgets.QDialog):
			# 	verbose.warning("No category could be found for '%s'. The widget's value cannot be stored." %self.base_widget)
			# 	return None
			# else:
			try:
				return self.findCategory(widget.parent())
			except TypeError:
				# verbose.warning("No category could be found for '%s'. The widget's value cannot be stored." %self.base_widget)
				return "none"


	def addContextMenu(self, widget, name, command, icon=None, tintNormal=True):
		"""Add context menu item to widget.

		'widget' should be a Push Button or Tool Button.
		'name' is the text to be displayed in the menu.
		'command' is the function to run when the item is triggered.
		'icon' is a pixmap to use for the item's icon (optional).
		"""
		widget.setContextMenuPolicy(QtCore.Qt.ActionsContextMenu)
		# Remove illegal characters from name
		actionName = "action%s" % re.sub(r"[^\w]", "_", name)

		action = QtWidgets.QAction(name, None)
		if icon:
			action.setIcon(self.iconSet(icon, tintNormal=tintNormal))
		action.setObjectName(actionName)
		action.triggered.connect(command)
		widget.addAction(action)

		# Make a class-scope reference to this object
		# (won't work without it for some reason)
		exec_str = "self.%s = action" % actionName
		exec(exec_str)

		return action


	def iconSet(self, icon_name, tintNormal=True):
		"""Return a QIcon using the specified image.

		Generate tinted pixmaps for normal/disabled/active/selected states.
		tintNormal: whether to tint the normal state icon or leave it as-is.
		"""
		icon = QtGui.QIcon()

		if isinstance(tintNormal, QtGui.QColor):
			icon.addPixmap(
				self.iconTint(icon_name, tint=tintNormal), 
				QtGui.QIcon.Normal, QtGui.QIcon.Off)
		elif tintNormal is False:
			icon.addPixmap(
				self.iconTint(icon_name), 
				QtGui.QIcon.Normal, QtGui.QIcon.Off)
		else:
			icon.addPixmap(
				self.iconTint(icon_name, tint=self.col['text']), 
				QtGui.QIcon.Normal, QtGui.QIcon.Off)

		icon.addPixmap(
			self.iconTint(icon_name, tint=self.col['disabled']), 
			QtGui.QIcon.Disabled, QtGui.QIcon.Off)
		icon.addPixmap(
			self.iconTint(icon_name, tint=self.col['highlighted-text']), 
			QtGui.QIcon.Active, QtGui.QIcon.Off)
		icon.addPixmap(
			self.iconTint(icon_name, tint=self.col['highlighted-text']), 
			QtGui.QIcon.Selected, QtGui.QIcon.Off)

		return icon


	def iconTint(self, icon_name, tint=None):
		"""Return a QPixmap using the specified PNG or SVG image.

		If tint (QColor) is given, tint the image with the given color.
		SVG processing taken from the answer here:
		https://stackoverflow.com/questions/25671275
		"""
		search_locations = [
			'icons', 
			# os.path.join(os.environ['IC_BASEDIR'], 'shared', 'icons'), 
			# os_wrapper.absolute_path('./icons')
		]

		icon_path = self.checkFilePath(icon_name, searchpath=search_locations)
		if icon_path is None:
			# verbose.warning("Could not find icon: %s" % icon_name)
			pixmap = QtGui.QPixmap()

		else:
			if icon_name.endswith('svg'):
				w, h = 64, 64
				svg_renderer = QtSvg.QSvgRenderer(icon_path)
				image = QtGui.QImage(w, h, QtGui.QImage.Format_ARGB32)
				image.fill(0x00000000)  # Set the ARGB to 0 to prevent rendering artifacts
				svg_renderer.render(QtGui.QPainter(image))
				pixmap = QtGui.QPixmap.fromImage(image)
			else:
				pixmap = QtGui.QPixmap(icon_path)

			# Initialize painter to draw on a pixmap and set composition mode
			if tint is not None:
				painter = QtGui.QPainter()
				painter.begin(pixmap)
				painter.setCompositionMode(painter.CompositionMode_SourceIn)
				painter.setBrush(tint)
				painter.setPen(tint)
				painter.drawRect(pixmap.rect())
				painter.end()

		return pixmap


	def toggleWidgets(self, custom_property, visibility, parent_object):
		"""Show/hide all child widgets of 'parent_object' with specified
		custom property.
		Used to hide expert mode or experimental UI elements.
		"""
		types = (
			QtWidgets.QMenu, 
			QtWidgets.QMenuBar, 
			QtWidgets.QAction, 
			QtWidgets.QPushButton, 
			QtWidgets.QToolButton, 
			QtWidgets.QCheckBox, 
			QtWidgets.QComboBox, 
			QtWidgets.QFrame
		)

		try:
			for item in parent_object.findChildren(types):
				if item.property(custom_property):
					item.setVisible(visibility)

		# Fix for Qt4 where findChildren signature doesn't suport a tuple for
		# an argument...
		except TypeError:
			expert_items = []
			for widget_type in types:
				for item in parent_object.findChildren(widget_type):
					if item.property(custom_property):
						expert_items.append(item)
			for item in expert_items:
				item.setVisible(visibility)


	def conformFormLayoutLabels(self, parentObject, padding=8):
		"""Conform the widths of all labels in formLayouts under the specified
		parentObject for a more coherent appearance.

		'padding' is an amount in pixels to add to the max width.
		"""
		labels = []
		labelWidths = []

		# Find all labels in form layouts
		for layout in parentObject.findChildren(QtWidgets.QFormLayout):
			# print(layout.objectName())
			items = (layout.itemAt(i) for i in range(layout.count()))
			for item in items:
				widget = item.widget()
				if isinstance(widget, QtWidgets.QLabel):
					labels.append(widget)

		# Find labels in first column of grid layouts
		for layout in parentObject.findChildren(QtWidgets.QGridLayout):
			# print(layout.objectName())
			items = (layout.itemAt(i) for i in range(layout.count()))
			for item in items:
				widget = item.widget()
				if isinstance(widget, QtWidgets.QLabel):
					# Only items in first column (there's probably a neater
					# way to do this)
					if layout.getItemPosition(layout.indexOf(widget))[1] == 0:
						labels.append(widget)

		# Find label widths
		for label in labels:
			fontMetrics = QtGui.QFontMetrics(label.font())
			width = fontMetrics.width(label.text())
			# print('Width of "%s": %d px' %(label.text(), width))
			labelWidths.append(width)

		# Get widest label & set all labels widths to match
		if labelWidths:
			maxWidth = max(labelWidths)
			# print("Max label width : %d px (%d inc padding)" %(maxWidth, maxWidth+padding))
			for label in labels:
				label.setFixedWidth(maxWidth+padding)
				label.setAlignment(QtCore.Qt.AlignVCenter|QtCore.Qt.AlignRight)
				label.setProperty('formLabel', True)  # Set custom property for styling


	def toggleFormField(self, parentObject, field, enabled):
		"""Enable/disable a field in a form layout including its label."""

		layout = parentObject.findChildren(QtWidgets.QFormLayout)[0]
		label = layout.labelForField(field)

		field.setEnabled(enabled)
		label.setEnabled(enabled)


	def hideFormField(self, parentObject, field):
		"""Hide a field in a form layout including its label, and close up the
		remaining empty space.
		"""
		layout = parentObject.findChildren(QtWidgets.QFormLayout)[0]
		label = layout.labelForField(field)

		field.hide()
		label.hide()
		layout.removeWidget(field)
		layout.removeWidget(label)

		parentObject.toggled.emit(True)  # Force refresh


	def getCheckBoxValue(self, checkBox):
		"""Get the value from a checkbox and return a Boolean value."""

		if checkBox.checkState() == QtCore.Qt.Checked:
			return True
		else:
			return False


	def getWidgetMeta(self, widget):
		"""Get custom attribute value and category from UI widget."""

		if widget.property('oldToolTip'):  # Revert to old tooltip
			widget.setToolTip(widget.property('oldToolTip'))

		self.setDynamicProperty(widget, 'inheritedValue', False)

		category = widget.property('xmlCategory')
		attr = widget.property('xmlTag')
		return category, attr


	def setDynamicProperty(self, widget, property_name, property_value):
		"""Set a dymanic property for a widget, and redraw it."""

		widget.setProperty(property_name, property_value)
		widget.style().unpolish(widget)
		widget.style().polish(widget)


	# @QtCore.Slot()
	def execPushButton(self):
		"""Execute the function associated with a button.

		***NOT YET IMPLEMENTED***
		"""
		# verbose.detail("%s %s" %(self.sender().objectName(), self.sender().property('exec')))
		print("%s %s" %(self.sender().objectName(), self.sender().property('exec')))


	# @QtCore.Slot()
	def storeColor(self):
		"""Get the colour from a dialog opened from a colour chooser button.
		"""
		widget = self.sender()

		# Get current colour and pass to function
		current_color = widget.palette().color(QtGui.QPalette.Background)
		color = self.colorPickerDialog(current_color)
		if color:
			widget.setStyleSheet("QWidget { background-color: %s }" % color.name())
			category, attr = self.getWidgetMeta(self.sender())
			self.storeValue(category, attr, color.name())


	# @QtCore.Slot()
	def storeSliderValue(self):
		"""Get the value from a Slider and store in data."""

		category, attr = self.getWidgetMeta(self.sender())
		value = self.sender().value()
		self.storeValue(category, attr, value)


	# @QtCore.Slot()
	def storeSpinBoxValue(self):
		"""Get the value from a Spin Box and store in data."""

		category, attr = self.getWidgetMeta(self.sender())
		value = self.sender().value()
		self.storeValue(category, attr, value)


	# @QtCore.Slot()
	def storeLineEditValue(self):
		"""Get the value from a Line Edit and store in data."""

		category, attr = self.getWidgetMeta(self.sender())
		value = self.sender().text()
		self.storeValue(category, attr, value)


	# @QtCore.Slot()
	def storeTextEditValue(self):
		"""Get the value from a Plain Text Edit and store in data."""

		category, attr = self.getWidgetMeta(self.sender())
		value = self.sender().toPlainText()
		self.storeValue(category, attr, value)


	# @QtCore.Slot()
	def storeCheckBoxValue(self):
		"""Get the value from a Check Box and store in data."""

		category, attr = self.getWidgetMeta(self.sender())
		value = self.getCheckBoxValue(self.sender())
		self.storeValue(category, attr, value)


	# @QtCore.Slot()
	def storeRadioButtonValue(self):
		"""Get the value from a Radio Button group and store in data."""

		if self.sender().isChecked():
			category, attr = self.getWidgetMeta(self.sender())
			value = self.sender().text()
			self.storeValue(category, attr, value)


	# @QtCore.Slot()
	def storeComboBoxValue(self):
		"""Get the value from a Combo Box and store in data."""

		category, attr = self.getWidgetMeta(self.sender())
		value = self.sender().currentText()
		self.storeValue(category, attr, value)

		# Store combo box history
		if self.sender().property('storeHistory'):
			max_count = self.sender().maxCount()
			self.sender().setMaxCount(max_count-1)
			self.sender().setMaxCount(max_count)
			items = [self.sender().itemText(i) for i in range(self.sender().count())]
			self.storeValue(category, "%s_history" % attr, items)


	# @QtCore.Slot()
	def storeListWidgetValues(self):
		"""Get the values from a List Widget as a list and store in data."""

		widget = self.sender()
		category, attr = self.getWidgetMeta(widget)
		items = []
		for i in range(widget.count()):
			items.append(widget.item(i).text())
		self.storeValue(category, attr, items)


	def storeValue(self, category, attr, value=None):
		"""Store value in data."""

		ignore_list = ["null", "none", ""]
		if (category.lower() in ignore_list) or (attr.lower() in ignore_list):
			# verbose.warning("Null category.")
			return

		currentAttrStr = "%20s %s.%s" % (type(value), category, attr)

		try:
			self.prefs.set_attr(category, attr, value)  # str(value)
			# if int(os.getenv('IC_VERBOSITY')) < 5:
			# 	verbose.print_("%s=%s" % (currentAttrStr, value), inline=True)
			# else:
			# 	verbose.print_("%s=%s" % (currentAttrStr, value))
		except AttributeError as e:
			pass
			# verbose.error("Could not store value: %s " % str(e))


	# @QtCore.Slot()
	def toggleExpandGroup(self):
		"""Toggle expansion of custom rollout group box control."""

		groupBox = self.sender()
		state = groupBox.isChecked()
		if state:
			groupBox.setFixedHeight(groupBox.sizeHint().height())
		else:
			groupBox.setFixedHeight(20)  # Slightly hacky - needs to match value defined in QSS

		#self.setFixedHeight(self.sizeHint().height())  # Resize window


	def populateComboBox(self, comboBox, contents, replace=True, addEmptyItems=False, blockSignals=False):
		"""Use a list (contents) to populate a combo box.

		If 'replace' is true, the existing items will be replaced,
		otherwise the contents will be appended to the existing items.
		"""
		if blockSignals:
			comboBox.blockSignals(True)

		# Store current value
		current = comboBox.currentText()

		# Clear menu
		if replace:
			comboBox.clear()

		# Populate menu
		if contents:
			for item in contents:
				if addEmptyItems:
					comboBox.addItem(item)
				else:
					if item:
						comboBox.addItem(item)

		# Set to current value
		index = comboBox.findText(current)
		if index == -1:
			comboBox.setCurrentIndex(0)
		else:
			comboBox.setCurrentIndex(index)

		if blockSignals:
			comboBox.blockSignals(False)


	def setComboBox(self, comboBox, text):
		"""Set a combo box to a specific value, as long as it exists as an
		option.
		"""
		index = comboBox.findText(text)

		if index != -1:
			comboBox.setCurrentIndex(index)
			return True
		else:
			# verbose.detail("Unable to set %s to %s" % (comboBox.objectName(), text))
			comboBox.setCurrentIndex(0)
			return False

	# End widget handlers
	# ------------------------------------------------------------------------


	def checkFilePath(self, filename, searchpath=[]):
		"""Check if 'filename' exists.

		If not, search through list of folders given in the optional
		searchpath, then check in the current dir.
		"""
		if filename is None:
			return None
		if os.path.isfile(filename):
			return filename
		else:
			# Append current dir to searchpath and try each in turn
			searchpath.append(os.path.dirname(__file__))
			# print(searchpath)
			for folder in searchpath:
				filepath = os.path.join(folder, filename)
				if os.path.isfile(filepath):
					return filepath

		# File not found
		return None


	def loadStyleSheet(self):
		"""Load/reload stylesheet."""

		if self.stylesheet:
			with open(self.stylesheet, 'r') as fh:
				stylesheet = fh.read()

			# Dynamic style --------------------------------------------------
			# Read predefined colour variables and apply them to the style
			for key, value in self.col.items():
				rgb = "%d, %d, %d" %(value.red(), value.green(), value.blue())
				stylesheet = stylesheet.replace("%"+key+"%", rgb)

			# Replace image theme tokens
			stylesheet = stylesheet.replace(r"%theme%", self.imgtheme)

			# Replace font tokens
			if platform.system() == 'Windows':
				stylesheet = stylesheet.replace(r"%systemfont%", "'Segoe UI'")
			else:
				stylesheet = stylesheet.replace(r"%systemfont%", "")
			# ----------------------------------------------------------------

			self.setStyleSheet(stylesheet)
			return stylesheet


	def saveStyleSheet(self, output_name='style_out.qss'):
		"""Write stylesheet and bake tokens for compatibility."""

		stylesheet = self.loadStyleSheet()

		with open(output_name, 'w') as fh:
			fh.write("/* Generated by uistyle */\n")
			fh.write(stylesheet)


	def unloadStyleSheet(self):
		"""Unload stylesheet."""

		self.setStyleSheet("")


	def offsetColor(self, input_color, amount, clamp=None):
		"""Offset input_color by a given amount.

		Only works in greyscale.
		"""
		if amount == 0:  # Do nothing
			return input_color

		elif amount > 0:  # Lighten
			if clamp is None:
				min_clamp = 0
			else:
				min_clamp = clamp
			max_clamp = 255

		elif amount < 0:  # Darken
			min_clamp = 0
			if clamp is None:
				max_clamp = 255
			else:
				max_clamp = clamp

		lum = max(min_clamp, min(input_color.lightness()+amount, max_clamp))
		return QtGui.QColor(lum, lum, lum)


	def computeUIPalette(self):
		"""Compute complementary UI colours based on window colour."""

		self.col['group-bg'] = QtGui.QColor(128, 128, 128)
		self.col['line'] = self.col['window'].darker(110)
		self.col['mandatory'] = QtGui.QColor('#f92672')
		self.col['warning'] = QtGui.QColor('#e6db74')
		self.col['inherited'] = QtGui.QColor('#a1efe4')

		if self.col['window'].lightness() < 128:  # Dark UI
			self.imgtheme = "light"
			self.col['text'] = QtGui.QColor(204, 204, 204)
			self.col['disabled'] = self.offsetColor(self.col['window'], +51)
			self.col['base'] = self.offsetColor(self.col['window'], -34, 34)
			self.col['alternate'] = self.offsetColor(self.col['base'], +8)
			self.col['button'] = self.offsetColor(self.col['window'], +34, 102)
			self.col['button-border'] = self.offsetColor(self.col['button'], +8)
			self.col['menu-bg'] = self.offsetColor(self.col['window'], -17, 68)
			self.col['menu-border'] = self.offsetColor(self.col['menu-bg'], +17)
			self.col['group-header'] = self.offsetColor(self.col['window'], +17)
		else:  # Light UI
			self.imgtheme = "dark"
			self.col['text'] = QtGui.QColor(51, 51, 51)
			self.col['disabled'] = self.offsetColor(self.col['window'], -51)
			self.col['base'] = self.offsetColor(self.col['window'], +34, 221)
			self.col['alternate'] = self.offsetColor(self.col['base'], -8)
			self.col['button'] = self.offsetColor(self.col['window'], -17, 204)
			self.col['button-border'] = self.offsetColor(self.col['button'], -8)
			self.col['menu-bg'] = self.offsetColor(self.col['window'], +17, 187)
			self.col['menu-border'] = self.offsetColor(self.col['menu-bg'], -17)
			self.col['group-header'] = self.offsetColor(self.col['window'], -17)

		self.col['hover'] = self.offsetColor(self.col['button'], +17)
		self.col['checked'] = self.offsetColor(self.col['button'], -17)
		self.col['pressed'] = self.col['checked'] #self.col['highlight']

		if self.col['highlight'].lightness() < 136:
			self.col['highlighted-text'] = QtGui.QColor(255, 255, 255)
		else:
			self.col['highlighted-text'] = QtGui.QColor(0, 0, 0)

		# if self.col['button'].lightness() < 170:
		# 	self.col['button-text'] = self.offsetColor(self.col['button'], +68, 204)
		# else:
		# 	self.col['button-text'] = self.offsetColor(self.col['button'], -68, 51)
		self.col['button-text'] = self.col['text']

		self.col['mandatory-bg'] = self.col['mandatory']
		if self.col['mandatory-bg'].lightness() < 128:
			self.col['mandatory-text'] = self.offsetColor(self.col['mandatory-bg'], +68, 204)
		else:
			self.col['mandatory-text'] = self.offsetColor(self.col['mandatory-bg'], -68, 51)

		self.col['warning-bg'] = self.col['warning']
		if self.col['warning-bg'].lightness() < 128:
			self.col['warning-text'] = self.offsetColor(self.col['warning-bg'], +68, 204)
		else:
			self.col['warning-text'] = self.offsetColor(self.col['warning-bg'], -68, 51)

		self.col['inherited-bg'] = self.col['inherited']
		if self.col['inherited-bg'].lightness() < 128:
			self.col['inherited-text'] = self.offsetColor(self.col['inherited-bg'], +68, 204)
		else:
			self.col['inherited-text'] = self.offsetColor(self.col['inherited-bg'], -68, 51)


	# @QtCore.Slot()
	def setUIBrightness(self, value):
		"""Set the UI style background shade."""

		#print(value)
		self.col['window'] = QtGui.QColor(value, value, value)
		self.computeUIPalette()
		self.loadStyleSheet()


	# @QtCore.Slot()
	def setAccentColor(self, color=None):
		"""Set the UI style accent colour."""

		widget = self.sender()

		# Get current colour and pass to function
		current_color = widget.palette().color(QtGui.QPalette.Background)
		color = self.colorPickerDialog(current_color)
		if color:
			widget.setStyleSheet("QWidget { background-color: %s }" % color.name())
			self.col['highlight'] = color
			self.computeUIPalette()
			self.loadStyleSheet()
		# self.col['highlight'] = widget.palette().color(QtGui.QPalette.Background)
		# self.computeUIPalette()
		# self.loadStyleSheet()


	def storeWindow(self):
		"""Store window geometry and state.

		(Save state may cause issues with PyQt5)
		"""
		if self.store_window_geometry:
			try:
				self.settings.setValue("geometry", self.saveGeometry())
				# verbose.detail("Storing window geometry for '%s'." %self.objectName())
			except:
				# verbose.warning("Could not store window geometry for '%s'." % self.objectName())
				print("Could not store window geometry for '%s'." % self.objectName())

			# if ENVIRONMENT == 'standalone':
			# 	verbose.detail("Storing window geometry for '%s'." %self.objectName())
			# 	try:
			# 		self.settings.setValue("geometry", self.saveGeometry())
			# 		# self.settings.setValue("windowState", self.saveState())
			# 	except:
			# 		pass


	def storeWidgetState(self, widget, storage_attr):
		"""Store widget state."""

		try:
			self.settings.setValue(storage_attr, widget.saveState())
		except (AttributeError, TypeError):
			# verbose.warning("Could not store widget state for '%s'." % widget.objectName())
			print("Could not store widget state for '%s'." % widget.objectName())


	def restoreWidgetState(self, widget, storage_attr):
		"""Restore and apply saved state of a widget."""

		try:
			widget.restoreState(self.settings.value(storage_attr)) #.toByteArray())
		except (AttributeError, TypeError):
			# verbose.warning("Could not restore widget state for '%s'." % widget.objectName())
			print("Could not restore widget state for '%s'." % widget.objectName())


	# def showEvent(self, event):
	# 	"""Event handler for when window is shown."""
	# 
	# 	pass


	# def closeEvent(self, event):
	# 	"""Event handler for when window is closed."""
	# 
	# 	self.storeWindow()
	# 	QtWidgets.QMainWindow.closeEvent(self, event)
	# 	#self.closeEvent(self, event)


	def save(self):
		"""Save data."""

		if self.prefs:
			return self.prefs.save()


	# def saveAndExit(self):
	# 	"""Save data and close window."""
	# 
	# 	if self.save():
	# 		self.returnValue = True
	# 		self.hide()
	# 		self.ui.hide()
	# 		#self.exit()
	# 	else:
	# 		self.exit()


	# def exit(self):
	# 	"""Exit the window with negative return value."""
	# 
	# 	self.storeWindow()
	# 	#self.returnValue = False
	# 	self.hide()

# ----------------------------------------------------------------------------
# End of main window class
# ============================================================================
# DCC application helper functions
# ----------------------------------------------------------------------------

def _main_window(app=ENVIRONMENT):
	"""Return specified app's main window instance.

	We need this in order for our Qt dialogs to be correctly parented as a
	sub-window. For apps that don't use Qt for their UI, various hacks may
	need to be deployed...
	"""
	if app in ['standalone', 'generic']:
		return None

	# Blender (not Qt)
	# Requires bqt - see https://github.com/techartorg/bqt
	elif app == 'blender':
		obj = QtWidgets.QApplication.instance().blender_widget
		if obj:
			return obj

	# Clarisse (not Qt)
	# elif app == 'clarisse':
	# 	for obj in QtWidgets.QApplication.topLevelWidgets():
	# 		if obj.inherits('QMainWindow'):
	# 			return obj

	# Houdini
	elif app == 'houdini':
		obj = hou.qt.mainWindow()
		if obj:
			return obj

	# Maya
	elif app == 'maya':
		for obj in QtWidgets.QApplication.topLevelWidgets():
			if obj.objectName() == 'MayaWindow':
				return obj

	# Max
	elif app == 'max':
		# obj = QtWidgets.QWidget.find(runtime.windows.getMAXHWND())  # seems unstable?
		obj = qtmax.GetQMaxMainWindow()
		if obj:
			return obj

	# Nuke
	elif app == 'nuke':
		for obj in QtWidgets.QApplication.topLevelWidgets():
			if (obj.inherits('QMainWindow') and obj.metaObject().className() == 'Foundry::UI::DockMainWindow'):
				return obj

	else:
		# raise RuntimeError("Could not find %s's main window instance" % app)
		# verbose.warning("Could not find %s's main window instance" % app)
		print("Could not find %s's main window instance" % app)
		return None


# MAYA -----------------------------------------------------------------------

def _maya_delete_ui(window_object, window_title):
	"""Delete existing UI in Maya."""

	if mc.window(window_object, query=True, exists=True):
		mc.deleteUI(window_object)  # Delete window
	if mc.dockControl('MayaWindow|' + window_title, query=True, exists=True):
		mc.deleteUI('MayaWindow|' + window_title)  # Delete docked window


# NUKE -----------------------------------------------------------------------

def _nuke_delete_ui(window_object, window_title):
	"""Delete existing UI in Nuke."""

	for obj in QtWidgets.QApplication.allWidgets():
		if obj.objectName() == window_object:
			obj.deleteLater()


def _nuke_set_zero_margins(widget_object):
	"""Remove Nuke margins when docked UI.

	More info: https://gist.github.com/maty974/4739917
	"""
	parentApp = QtWidgets.QApplication.allWidgets()
	parentWidgetList = []
	for parent in parentApp:
		for child in parent.children():
			if widget_object.__class__.__name__ == child.__class__.__name__:
				parentWidgetList.append(parent.parentWidget())
				parentWidgetList.append(parent.parentWidget().parentWidget())
				parentWidgetList.append(parent.parentWidget().parentWidget().parentWidget())

				for sub in parentWidgetList:
					for tinychild in sub.children():
						try:
							tinychild.setContentsMargins(0, 0, 0, 0)
						except:
							pass
